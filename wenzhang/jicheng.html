<span>
一、原型链的继承<br/>
<img src="img/jc_1.png"/><br/>

特点：<br/>
1、非常纯粹的继承关系，实例是子类的实例，也是父类的实例<br/>
2、父类新增原型方法/原型属性，子类都能访问到<br/>
3、简单，易于实现<br/>
缺点：<br/>
1、要想为子类新增属性和方法，必须要在new Animal()这样的语句之后执行，不能放到构造器中<br/>
2、无法实现多继承<br/>
3、来自原型对象的引用属性是所有实例共享的<br/>
4、创建子类实例时，无法向父类构造函数传参<br/>

二、构造继承<br/>
<img class="img-responsive" src="img/jc_2.png"/><br/>
特点：<br/>
1、解决了1中，子类实例共享父类引用属性的问题<br/>
2、创建子类实例时，可以向父类传递参数<br/>
3、可以实现多继承（call多个父类对象）<br/>
缺点：<br/>
1、实例并不是父类的实例，只是子类的实例<br/>
2、只能继承父类的实例属性和方法，不能继承原型属性/方法<br/>
3、无法实现函数复用，每个子类都有父类实例函数的副本，影响性能<br/>

三、实例继承<br/>
<img class="img-responsive" src="img/jc_3.png"><br/>
特点：<br/>
1、不限制调用方式，不管是new 子类()还是子类(),返回的对象具有相同的效果<br/>
缺点：<br/>
1、实例是父类的实例，不是子类的实例<br/>
2、不支持多继承<br/>

四、拷贝继承<br/>
<img class="img-responsive" src="img/jc_4.png"><br/>
特点：
1、支持多继承<br/>
缺点：<br/>
1、效率较低，内存占用高（因为要拷贝父类的属性）<br/>
2、无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到）<br/>

五、组合继承<br/>
<img class="img-responsive" src="img/jc_5.png"><br/>
特点：<br/>
1、弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法<br/>
2、既是子类的实例，也是父类的实例<br/>
3、不存在引用属性共享问题<br/>
4、可传参<br/>
5、函数可复用<br/>
缺点：<br/>
1、调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）<br/>

六、寄生组合继承<br/>
<img class="img-responsive" src="img/jc_6.png"><br/>
特点：<br/>
1、堪称完美<br/>
缺点：<br/>
1、实现较为复杂<br/>


</span>